// ======================  01
// Функції не відрізняються від чисел, рядків або масивів - це просто спеціальний тип даних (об'єкт вищого порядку), значення, яке можна зберігати у змінній або передавати у якості аргументу в іншу функцію.

// function greet(name) {
//   return `Ласкаво просимо ${name}.`;
// }

// // Викликаємо функцію greet
// // і виводимо результат у консоль
// console.log(greet("Mango"));
// // Ласкаво просимо Манго.

// // Виводимо функцію greet
// // у консоль, не викликаючи її
// console.log(greet);
// /*
// ƒ greet() {
//      return `Ласкаво просимо ${name}.`;
// }
// */
// У першому лозі ми викликаємо функцію greet за допомогою круглих дужок, і в консоль виводиться результат її виконання. У другому лозі передається посилання на функцію, а не результат її виклику (відсутні круглі дужки), тому в консоль виводиться її тіло. Це означає, що функцію можна присвоїти у змінну або передати як аругмент іншої функції.

// ---
// Доповни код таким чином, щоб у змінній result був результат виконання функції makePizza, а у змінній pointer було посилання на функцію makePizza.

// Оголошена функція makePizza
// Оголошена змінна result
// Значення змінної result - це рядок "Your pizza is being prepared, please wait."
// Значення змінної result отримане за допомогою виклику функції
// Оголошена змінна pointer
// Значення змінної pointer - це посилання на функцію makePizza

// function makePizza() {
//    return "Your pizza is being prepared, please wait.";
//  }
//  // Change code below this line
 
//  const result = makePizza();
//  const pointer = makePizza;

//  console.log(result);
//  console.log(pointer);


// =================================  02
// Доповни функцію makeMessage таким чином, щоб вона очікувала другим параметром (параметр callback) колбек-функцію і повертала її виклик. Функція deliverPizza або makePizza буде передаватися як колбек і очікувати аргументом ім'я готової піци, що доставляється.

// Оголошена функція deliverPizza
// Оголошена функція makePizza
// Оголошена функція makeMessage
// Функція makeMessage приймає два параметри, названі відповідно до завдання, pizzaName і callback
// Виклик makeMessage("Royal Grand", makePizza) повертає рядок "Pizza Royal Grand is being prepared, please wait..."
// Виклик makeMessage("Ultracheese", deliverPizza) повертає рядок "Delivering Ultracheese pizza."

// function deliverPizza(pizzaName) {
//    return `Delivering ${pizzaName} pizza.`;
//  }
 
//  function makePizza(pizzaName) {
//    return `Pizza ${pizzaName} is being prepared, please wait...`;
//  }
 
//  // Chande code below this line
//  function makeMessage(pizzaName, callback) {
//    return callback(pizzaName);
//  }

 
//  console.log(makeMessage("Royal Grand", makePizza));
//  console.log(makeMessage("Ultracheese", deliverPizza));


// ================================  03
// Доповни другий виклик функції makePizza(pizzaName, callback), передавши другим аргументом інлайн колбек-функцію eatPizza(pizzaName), яка логує рядок "Eating pizza <назва піци>".

// Оголошена функція makePizza
// Функція makePizza приймає два параметри
// Другим аргументом під час виклику makePizza("Ultracheese") передана функція eatPizza з єдиним параметром pizzaName

function makePizza(pizzaName, callback) {
   console.log(`Pizza ${pizzaName} is being prepared, please wait...`);
   callback(pizzaName);
 }
 
 makePizza("Royal Grand", function deliverPizza(pizzaName) {
   console.log(`Delivering pizza ${pizzaName}.`);
 });
 // Change code below this line
 
 makePizza("Ultracheese", function eatPizza(pizzaName) {
   console.log(`Eating pizza ${pizzaName}.`);
 });

 
//  ===================================  04
// Необхідно написати логіку обробки замовлення піци. Виконай рефакторинг методу order таким чином, щоб він приймав другим і третім параметром два колбеки onSuccess і onError.

// Якщо у властивості pizzas відсутня піца з назвою з параметра pizzaName, метод order повинен повертати результат виклику колбека onError, передаючи йому аргументом рядок "There is no pizza with a name <назва піци> in the assortment."
// Якщо у властивості pizzas присутня піца з назвою з параметра pizzaName, метод order повинен повертати результат виклику колбека onSuccess, передаючи йому аргументом назву замовленої піци.
// Після оголошення об'єкта pizzaPalace ми додали колбеки і виклики методів. Будь ласка, нічого там не міняй.

// Метод order оголошує три параметри
// Виклик pizzaPalace.order("Smoked", makePizza, onOrderError) повертає "Your order is accepted. Cooking pizza Smoked."
// Виклик pizzaPalace.order("Four meats", makePizza, onOrderError) повертає "Your order is accepted. Cooking pizza Four meats."
// Виклик pizzaPalace.order("Big Mike", makePizza, onOrderError) повертає "Error! There is no pizza with a name Big Mike in the assortment."
// Виклик pizzaPalace.order("Vienna", makePizza, onOrderError) повертає "Error! There is no pizza with a name Vienna in the assortment."

// const pizzaPalace = {
//    pizzas: ["Ultracheese", "Smoked", "Four meats"],
//    order(pizzaName, onSuccess, onError) {
//       if (this.pizzas.includes(pizzaName)) {
//          return onSuccess(pizzaName);
//       } else {
//          return onError (`There is no pizza with a name ${pizzaName} in the assortment.`)
//       }
//    },
//  };
//  // Change code above this line
 
//  // Callback for onSuccess
//  function makePizza(pizzaName) {
//    return `Your order is accepted. Cooking pizza ${pizzaName}.`;
//  }
 
//  // Callback for onError
//  function onOrderError(error) {
//    return `Error! ${error}`;
//  }
 
//  // Method calls with callbacks
//  pizzaPalace.order("Smoked", makePizza, onOrderError);
//  pizzaPalace.order("Four meats", makePizza, onOrderError);
//  pizzaPalace.order("Big Mike", makePizza, onOrderError);
//  pizzaPalace.order("Vienna", makePizza, onOrderError);

//  console.log(pizzaPalace.order("Smoked", makePizza, onOrderError));
//  console.log(pizzaPalace.order("Four meats", makePizza, onOrderError));
//  console.log(pizzaPalace.order("Big Mike", makePizza, onOrderError));
//  console.log(pizzaPalace.order("Vienna", makePizza, onOrderError));


// =======================================  05
// Метод перебирання масиву, який використовується для заміни циклів for і for...of в роботі з колекцією.

// массив.forEach(function callback(element, index, array) {
//   // Тіло колбек-функції
// });
// Поелементо перебирає масив.
// Викликає колбек-функцію для кожного елемента масиву.
// Нічого не повертає.
// Аргументи колбек-функції - це значення поточного елемента element, його індекс index і власне вихідний масив array. Можна оголошувати тільки необхідні параметри, найчастіше - це елемент, головне не забувати про їх порядок.

// const numbers = [5, 10, 15, 20, 25];

// // Класичний for
// for (let i = 0; i < numbers.length; i += 1) {
//   console.log(`Індекс ${i}, значення ${numbers[i]}`);
// }

// // Метод перебирання forEach
// numbers.forEach(function (number, index) {
//   console.log(`Індекс ${index}, значення ${number}`);
// });
// Єдиним випадком, коли варто використовувати цикли for або for...of для перебирання масиву, - це задачі з перериванням виконання циклу. Перервати виконання методу forEach не можна, він завжди перебирає масив до кінця.
// ---
// Функція calculateTotalPrice(orderedItems) приймає один параметр orderedItems - масив чисел, і розраховує загальну суму його елементів, яка зберігається у змінній totalPrice і повертається як результат роботи функції.

// Виконай рефакторинг функції таким чином, щоб замість циклу for, вона використовувала метод forEach.

// Оголошена функція calculateTotalPrice(orderedItems)
// Для перебирання масиву orderedItems використаний метод forEach
// Виклик функції calculateTotalPrice([12, 85, 37, 4]) повертає 138
// Виклик функції calculateTotalPrice([164, 48, 291]) повертає 503
// Виклик функції calculateTotalPrice([412, 371, 94, 63, 176]) повертає 1116
// Виклик функції з випадковими, але валідними аргументами, повертає правильне значення

// function calculateTotalPrice(orderedItems) {
//    let totalPrice = 0;
//    // Change code below this line
//    orderedItems.forEach(el => totalPrice += el);
 
//    // Change code above this line
//    return totalPrice;
//  }
 
//  console.log(calculateTotalPrice([12, 85, 37, 4]));
//  console.log(calculateTotalPrice([412, 371, 94, 63, 176]));


// =====================================  06
// ЗАДАЧА. ФІЛЬТРАЦІЯ МАСИВУ ЧИСЕЛ
// Функція filterArray(numbers, value) приймає масив чисел numbers і повертає новий масив, в якому будуть тільки ті елементи оригінального масиву, які більші за значення параметра value.

// Виконай рефакторинг функції таким чином, щоб замість циклу for, вона використовувала метод forEach.

// Оголошена функція filterArray(numbers, value)
// Для перебирання масиву numbers використаний метод forEach
// Виклик функції filterArray([1, 2, 3, 4, 5], 3) повертає [4, 5]
// Виклик функції filterArray([1, 2, 3, 4, 5], 4) повертає [5]
// Виклик функції filterArray([1, 2, 3, 4, 5], 5) повертає []
// Виклик функції filterArray([12, 24, 8, 41, 76], 38) повертає [41, 76]
// Виклик функції filterArray([12, 24, 8, 41, 76], 20) повертає [24, 41, 76]
// Виклик функції з випадковими, але валідними аргументами, повертає правильне значення

// function filterArray(numbers, value) {
//    const filteredNumbers = [];
//    // Change code below this line
//    numbers.forEach(el => {
//       if (el > value){
//          filteredNumbers.push(el);
//       }
//    }); 
//    // Change code above this line
//    return filteredNumbers;
//  }

//  console.log(filterArray([1, 2, 3, 4, 5], 3));


// ===========================================  07
// Функція getCommonElements(firstArray, secondArray) приймає два масиви довільної довжини в параметри firstArray і secondArray, і повертає новий масив їхніх спільних елементів, тобто тих, які присутні в обох масивах.

// Виконай рефакторинг функції таким чином, щоб замість циклу for, вона використовувала метод forEach.

// Оголошена функція getCommonElements(firstArray, secondArray)
// Для перебирання параметра (масиву) використаний метод forEach
// Виклик getCommonElements([1, 2, 3], [2, 4]) повертає [2]
// Виклик getCommonElements([1, 2, 3], [2, 1, 17, 19]) повертає [1, 2]
// Виклик getCommonElements([24, 12, 27, 3], [12, 8, 3, 36, 27]) повертає [12, 27, 3]
// Виклик getCommonElements([10, 20, 30, 40], [4, 30, 17, 10, 40]) повертає [10, 30, 40]
// Виклик getCommonElements([1, 2, 3], [10, 20, 30]) повертає []
// Виклик функції з випадковими, але валідними аргументами, повертає правильне значення

// function getCommonElements(firstArray, secondArray) {
//    const commonElements = [];
//    // Change code below this line
//    firstArray.forEach(el => {
//       if (secondArray.includes(el)) {
//          commonElements.push(el);
//        } 
//    });
 
//    return commonElements;
//    // Change code above this line
//  }
 
// console.log(getCommonElements([24, 12, 27, 3], [12, 8, 3, 36, 27]))


// =========================================  08
// Виконай рефакторинг функції calculateTotalPrice() таким чином, щоб вона була оголошена як стрілочна.

// Оголошена змінна calculateTotalPrice
// Змінній calculateTotalPrice присвоєна стрілочна функція з параметрами (quantity, pricePerItem)
// Виклик calculateTotalPrice(5, 100) повертає 500
// Виклик calculateTotalPrice(8, 60) повертає 480
// Виклик calculateTotalPrice(3, 400) повертає 1200
// Виклик функції з випадковими, але валідними аргументами, повертає правильне значення

// Change code below this line

// const calculateTotalPrice = (quantity, pricePerItem) => {
//    // Change code above this line
//    return quantity * pricePerItem;
//  }


// =========================================== 09
// Виконай рефакторинг функції calculateTotalPrice() таким чином, щоб вона використовувала неявне повернення.

// Оголошена змінна calculateTotalPrice
// Змінній calculateTotalPrice присвоєна стрілочна функція з параметрами (quantity, pricePerItem)
// У функції використане неявне повернення
// Виклик calculateTotalPrice(5, 100) повертає 500
// Виклик calculateTotalPrice(8, 60) повертає 480
// Виклик calculateTotalPrice(3, 400) повертає 1200
// Виклик функції з випадковими, але валідними аргументами, повертає правильне значення

// // Change code below this line
// const calculateTotalPrice = (quantity, pricePerItem) => quantity * pricePerItem;
//  // Change code above this line


// ==========================================  10
// Виконай рефакторинг функції calculateTotalPrice(orderedItems), замінивши її оголошення на стрілочну функцію. Заміни колбек-функцію, передану в метод forEach(), на стрілочну функцію.

// Оголошена змінна calculateTotalPrice
// Змінній calculateTotalPrice присвоєна стрілочна функція з параметром (orderedItems)
// Для перебирання масиву orderedItems використаний метод forEach
// Колбек для методу forEach - це стрілочна функція
// Виклик функції calculateTotalPrice([12, 85, 37, 4]) повертає 138
// Виклик функції calculateTotalPrice([164, 48, 291]) повертає 503
// Виклик функції calculateTotalPrice([412, 371, 94, 63, 176]) повертає 1116
// Виклик функції з випадковими, але валідними аргументами, повертає правильне значення

// Change code below this line
// const calculateTotalPrice = (orderedItems) => {
//    let totalPrice = 0;
 
//    orderedItems.forEach(item => totalPrice += item);
 
//    return totalPrice;
//  }
 // Change code above this line

 
//  ===============================================  11
// Заміни оголошення функції filterArray() і колбек для методу forEach() на стрілочні функції.

// Оголошена змінна filterArray
// Змінній filterArray присвоєна стрілочна функція з параметрами (numbers, value)
// Для перебирання масиву numbers використаний метод forEach
// Колбек для методу forEach - це стрілочна функція
// Виклик функції filterArray([1, 2, 3, 4, 5], 3) повертає [4, 5]
// Виклик функції filterArray([1, 2, 3, 4, 5], 4) повертає [5]
// Виклик функції filterArray([1, 2, 3, 4, 5], 5) повертає []
// Виклик функції filterArray([12, 24, 8, 41, 76], 38) повертає [41, 76]
// Виклик функції filterArray([12, 24, 8, 41, 76], 20) повертає [24, 41, 76]
// Виклик функції з випадковими, але валідними аргументами, повертає правильне значення

// // Change code below this line
// const filterArray = (numbers, value) => {
//    const filteredNumbers = [];
 
//    numbers.forEach(number => {
//      if (number > value) {
//        filteredNumbers.push(number);
//      }
//    });
 
//    // Change code above this line
//    return filteredNumbers;
//  }

//  console.log(filterArray([1, 2, 3, 4, 5], 3));


// ==========================================  12
// Заміни оголошення функції getCommonElements() і колбек для методу forEach() на стрілочні функції.

// Оголошена змінна getCommonElements.
// Змінній getCommonElements присвоєна стрілочна функція з параметрами (firstArray, secondArray)
// Для перебирання масиву firstArray використаний метод forEach
// Колбек для методу forEach - це стрілочна функція
// Виклик getCommonElements([1, 2, 3], [2, 4]) повертає [2]
// Виклик getCommonElements([1, 2, 3], [2, 1, 17, 19]) повертає [1, 2]
// Виклик getCommonElements([24, 12, 27, 3], [12, 8, 3, 36, 27]) повертає [12, 27, 3]
// Виклик getCommonElements([10, 20, 30, 40], [4, 30, 17, 10, 40]) повертає [10, 30, 40]
// Виклик getCommonElements([1, 2, 3], [10, 20, 30]) повертає []
// Виклик функції з випадковими, але валідними аргументами, повертає правильне значення

// Change code below this line
// const getCommonElements = (firstArray, secondArray) => {
//    const commonElements = [];
 
//    firstArray.forEach(element => {
//      if (secondArray.includes(element)) {
//        commonElements.push(element);
//      }
//    });
 
//    // Change code above this line
//    return commonElements;
//  }

//  console.log(getCommonElements([24, 12, 27, 3], [12, 8, 3, 36, 27]));


// =============================================  13
// Функція changeEven(numbers, value) приймає масив чисел numbers і оновлює кожен елемент, значення якого - це парне число, додаючи до нього значення параметра value.

// Виконай рефакторинг функції таким чином, щоб вона стала чистою - не змінювала масив чисел numbers, а створювала, наповнювала і повертала новий масив з оновленими значеннями.

// Оголошена функція changeEven(numbers, value)
// Функція changeEven не змінює значення параметра numbers
// Виклик changeEven([1, 2, 3, 4, 5], 10) повертає новий масив [1, 12, 3, 14, 5]
// Виклик changeEven([2, 8, 3, 7, 4, 6], 10) повертає новий масив [12, 18, 3, 7, 14, 16]
// Виклик changeEven([17, 24, 68, 31, 42], 100) повертає новий масив [17, 124, 168, 31, 142]
// Виклик changeEven([44, 13, 81, 92, 36, 54], 100) повертає новий масив [144, 13, 81, 192, 136, 154]
// Виклик функції з випадковими, але валідними аргументами, повертає правильне значення

function changeEven(numbers, value) {
   // Change code below this line
   for (let i = 0; i < numbers.length; i += 1) {
     if (numbers[i] % 2 === 0) {
       numbers[i] = numbers[i] + value;
     }
   }
   // Change code above this line
}


 